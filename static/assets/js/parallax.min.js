/*!
 * parallax.js v1.5.0 (http://pixelcog.github.io/parallax.js/)
 * @copyright 2016 PixelCog, Inc.
 * @license MIT (https://github.com/pixelcog/parallax.js/blob/master/LICENSE)
 */
(function($, window, document, undefined) {

  // Function to create a parallax instance for a given element
  function Parallax(element, options) {
    var self = this;

    // Remove specific properties from the options object to avoid conflicts
    if (typeof options === 'object') {
      delete options.refresh;
      delete options.render;
      $.extend(this, options);
    }

    // Store the element as a jQuery object
    this.$element = $(element);

    // If the element is an image tag, set imageSrc to its source attribute
    if (!this.imageSrc && this.$element.is("img")) {
      this.imageSrc = this.$element.attr("src");
    }

    // Parse the position option into an array
    var positionArray = (this.position + "").toLowerCase().match(/\S+/g) || [];
    if (positionArray.length < 1) {
      positionArray.push("center");
    }
    if (positionArray.length === 1) {
      positionArray.push(positionArray[0]);
    }
    if (["top", "bottom", "left", "right"].indexOf(positionArray[0]) !== -1 &&
      ["top", "bottom", "left", "right"].indexOf(positionArray[1]) !== -1) {
      positionArray = [positionArray[1], positionArray[0]];
    }
    if (this.positionX !== undefined) {
      positionArray[0] = this.positionX.toLowerCase();
    }
    if (this.positionY !== undefined) {
      positionArray[1] = this.positionY.toLowerCase();
    }
    this.positionX = positionArray[0];
    this.positionY = positionArray[1];
    if (this.positionX !== "left" && this.positionX !== "right") {
      if (isNaN(parseInt(this.positionX))) {
        this.positionX = "center";
      } else {
        this.positionX = parseInt(this.positionX);
      }
    }
    if (this.positionY !== "top" && this.positionY !== "bottom") {
      if (isNaN(parseInt(this.positionY))) {
        this.positionY = "center";
      } else {
        this.positionY = parseInt(this.positionY);
      }
    }
    this.position = this.positionX + (isNaN(this.positionX) ? "" : "px") + " " +
      this.positionY + (isNaN(this.positionY) ? "" : "px");

    // Check for specific user agents and apply fixes if necessary
    if (navigator.userAgent.match(/(iPod|iPhone|iPad)/)) {
      if (this.imageSrc && this.iosFix && !this.$element.is("img")) {
        this.$element.css({
          backgroundImage: "url(" + this.imageSrc + ")",
          backgroundSize: "cover",
          backgroundPosition: this.position
        });
      }
      return this;
    }

    if (navigator.userAgent.match(/(Android)/)) {
      if (this.imageSrc && this.androidFix && !this.$element.is("img")) {
        this.$element.css({
          backgroundImage: "url(" + this.imageSrc + ")",
          backgroundSize: "cover",
          backgroundPosition: this.position
        });
      }
      return this;
    }

    // Create a parallax mirror element
    this.$mirror = $("<div />").prependTo(this.mirrorContainer);

    // Check if the element has a slider child or create a new slider element
    var $sliderChild = this.$element.find(">.parallax-slider");
    var hasSliderChild = false;
    if ($sliderChild.length === 0) {
      this.$slider = $("<img />").prependTo(this.$mirror);
    } else {
      this.$slider = $sliderChild.prependTo(this.$mirror);
      hasSliderChild = true;
    }

    // Set up the classes and initial styles for mirror and slider
    this.$mirror.addClass("parallax-mirror").css({
      visibility: "hidden",
      zIndex: this.zIndex,
      position: "fixed",
      top: 0,
      left: 0,
      overflow: "hidden"
    });

    this.$slider.addClass("parallax-slider");

    // Handle the image load event and get the natural image dimensions
    this.$slider.one("load", function() {
      self.naturalHeight = this.naturalHeight || this.height || 1;
      self.naturalWidth = this.naturalWidth || this.width || 1;
      self.aspectRatio = self.naturalWidth / self.naturalHeight;

      // Call the setup function if it's not already set up
      if (!Parallax.isSetup) {
        Parallax.setup();
      }

      // Add this parallax instance to the sliders array and request render
      Parallax.sliders.push(self);
      Parallax.isFresh = false;
      Parallax.requestRender();
    });

    // Set the image source or trigger load event if already available
    if (!hasSliderChild) {
      this.$slider[0].src = this.imageSrc;
    }

    return this;
  }

  // Setup function to set up global variables and event listeners
  Parallax.setup = function() {
    var self = this;

    // Function to handle scroll and resize events
    function update() {
      if (prevScrollY === window.pageYOffset) {
        window.requestAnimationFrame(update);
        return false;
      }
      prevScrollY = window.pageYOffset;
      self.render();
      window.requestAnimationFrame(update);
    }

    // Function to handle resize event
    function onResize() {
      var $win = $(window);
      self.winHeight = $win.height();
      self.winWidth = $win.width();
      self.docHeight = $(document).height();
      self.docWidth = $(document).width();
      self.refresh();
      Parallax.isFresh = false;
      Parallax.requestRender();
    }

    // Store initial scroll and resize values
    var prevScrollY = window.pageYOffset;

    // Set up event listeners for scroll and resize
    $(window).on("scroll.px.parallax load.px.parallax", update);
    $(window).on("resize.px.parallax load.px.parallax", onResize);
    onResize();

    this.isReady = true;

    // Start updating the parallax elements
    var requestAnimationFrame = window.requestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      function(callback) {
        var currentTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currentTime - lastTime));
        var id = window.setTimeout(function() {
          callback(currentTime + timeToCall);
        }, timeToCall);
        lastTime = currentTime + timeToCall;
        return id;
      };

    var cancelAnimationFrame = window.cancelAnimationFrame ||
      window.webkitCancelAnimationFrame ||
      window.mozCancelAnimationFrame ||
      window.oCancelAnimationFrame ||
      window.msCancelAnimationFrame ||
      function(id) {
        clearTimeout(id);
      };

    function refresh() {
      Parallax.isFresh = true;
    }

    // Store useful references
    $.extend(this, {
      scrollTop: 0,
      scrollLeft: 0,
      winHeight: 0,
      winWidth: 0,
      docHeight: 1 << 30,
      docWidth: 1 << 30,
      sliders: [],
      isReady: false,
      isFresh: false,
      isBusy: false,
      requestRender: function() {
        var self = this;
        if (!this.isBusy) {
          this.isBusy = true;
          requestAnimationFrame(function() {
            self.render();
            self.isBusy = false;
          });
        }
      }
    });
  };

  // Function to refresh parallax dimensions
  Parallax.prototype.refresh = function() {
    this.boxWidth = this.$element.outerWidth();
    this.boxHeight = this.$element.outerHeight() + 2 * this.bleed;
    this.boxOffsetTop = this.$element.offset().top - this.bleed;
    this.boxOffsetLeft = this.$element.offset().left;
    this.boxOffsetBottom = this.boxOffsetTop + this.boxHeight;

    var scrollTop = Parallax.scrollTop;
    var winHeight = Parallax.winHeight;

    var s = Math.min(this.boxOffsetTop, Parallax.docHeight - winHeight);
    var h = Math.max(this.boxOffsetTop + this.boxHeight - winHeight, 0);
    var r = this.boxHeight + (s - h) * (1 - this.speed) | 0;
    var a = (this.boxOffsetTop - s) * (1 - this.speed) | 0;

    if (r * this.aspectRatio >= this.boxWidth) {
      this.imageWidth = r * this.aspectRatio | 0;
      this.imageHeight = r;
      this.offsetBaseTop = a;
      var t = this.imageWidth - this.boxWidth;
      if (this.positionX === "left") {
        this.offsetLeft = 0;
      } else if (this.positionX === "right") {
        this.offsetLeft = -t;
      } else if (isNaN(this.positionX)) {
        this.offsetLeft = -t / 2 | 0;
      } else {
        this.offsetLeft = Math.max(this.positionX, -t);
      }
    } else {
      this.imageWidth = this.boxWidth;
      this.imageHeight = this.boxWidth / this.aspectRatio | 0;
      this.offsetLeft = 0;
      var t = this.imageHeight - r;
      if (this.positionY === "top") {
        this.offsetBaseTop = a;
      } else if (this.positionY === "bottom") {
        this.offsetBaseTop = a - t;
      } else if (isNaN(this.positionY)) {
        this.offsetBaseTop = a - t / 2 | 0;
      } else {
        this.offsetBaseTop = a + Math.max(this.positionY, -t);
      }
    }
  };

  // Function to render parallax effect based on scroll position
  Parallax.prototype.render = function() {
    var scrollTop = Parallax.scrollTop;
    var overScroll = this.overScrollFix ? Parallax.overScroll : 0;
    var scrollBottom = scrollTop + Parallax.winHeight;

    if (this.boxOffsetBottom > scrollTop && this.boxOffsetTop <= scrollBottom) {
      this.visibility = "visible";
      this.mirrorTop = this.boxOffsetTop - scrollTop;
      this.mirrorLeft = this.boxOffsetLeft - Parallax.scrollLeft;
      this.offsetTop = this.offsetBaseTop - this.mirrorTop * (1 - this.speed);
    } else {
      this.visibility = "hidden";
    }

    this.$mirror.css({
      transform: "translate3d(" + this.mirrorLeft + "px, " + (this.mirrorTop - overScroll) + "px, 0px)",
      visibility: this.visibility,
      height: this.boxHeight,
      width: this.boxWidth
    });

    this.$slider.css({
      transform: "translate3d(" + this.offsetLeft + "px, " + this.offsetTop + "px, 0px)",
      position: "absolute",
      height: this.imageHeight,
      width: this.imageWidth,
      maxWidth: "none"
    });
  };

  // Set up some global variables and methods for the Parallax class
  Parallax.scrollTop = 0;
  Parallax.scrollLeft = 0;
  Parallax.winHeight = 0;
  Parallax.winWidth = 0;
  Parallax.docHeight = 1 << 30;
  Parallax.docWidth = 1 << 30;
  Parallax.sliders = [];
  Parallax.isSetup = false;
  Parallax.isFresh = false;
  Parallax.isBusy = false;

  // Function to configure Parallax options
  Parallax.configure = function(options) {
    if (typeof options === 'object') {
      delete options.refresh;
      delete options.render;
      $.extend(Parallax.prototype, options);
    }
  };

  // Function to refresh all Parallax instances
  Parallax.refresh = function() {
    $.each(Parallax.sliders, function() {
      this.refresh();
    });
    Parallax.isFresh = true;
  };

  // Function to render all Parallax instances
  Parallax.render = function() {
    $.each(Parallax.sliders, function() {
      this.render();
    });
  };

  // Function to request a render update
  Parallax.requestRender = function() {
    var self = this;
    if (!this.isBusy) {
      this.isBusy = true;
      window.requestAnimationFrame(function() {
        self.render();
        self.isBusy = false;
      });
    }
  };

  // Function to destroy a Parallax instance
  Parallax.destroy = function(element) {
    var $element = $(element);
    var parallaxInstance = $element.data("px.parallax");
    if (parallaxInstance) {
      parallaxInstance.$mirror.remove();
      var index = Parallax.sliders.indexOf(parallaxInstance);
      if (index !== -1) {
        Parallax.sliders.splice(index, 1);
      }
      $element.data("px.parallax", false);
    }
    if (Parallax.sliders.length === 0) {
      $(window).off("scroll.px.parallax resize.px.parallax load.px.parallax");
      Parallax.isReady = false;
      Parallax.isSetup = false;
    }
  };

  // Function to handle parallax initialization for elements
  Parallax.init = function(element) {
    var $element = $(element);
    if (element === window || element === document || $element.is("body")) {
      Parallax.configure($element.data());
    } else if ($element.data("px.parallax")) {
      Parallax.configure($element.data("px.parallax"));
    } else {
      var options = $.extend({}, $element.data(), { bleeds: 0 });
      $element.data("px.parallax", new Parallax(element, options));
    }
  };

  // Function to create a new Parallax instance or call specific methods
  $.fn.parallax = function(method) {
    return this.each(function() {
      if (typeof method === "string") {
        if (method === "destroy") {
          Parallax.destroy(this);
        } else if (Parallax.prototype.hasOwnProperty(method)) {
          Parallax.prototype[method].apply($(this).data("px.parallax"));
        }
      } else {
        Parallax.init(this);
      }
    });
  };

  // Alias the Parallax constructor
  $.fn.parallax.Constructor = Parallax;

  // Function to prevent conflicts with other libraries
  $.fn.parallax.noConflict = function() {
    $.fn.parallax = old;
    return this;
  };

  // Automatically initialize elements with data-parallax="scroll"
  $(function() {
    $('[data-parallax="scroll"]').parallax();
  });
})(jQuery, window, document);
